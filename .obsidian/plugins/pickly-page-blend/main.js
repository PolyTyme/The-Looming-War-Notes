/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PicklyPageBlendPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/publisher.ts
var Publisher = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.apiBaseUrl = "https://pb.pickly.space/api";
    this.basePath = "/pages";
    this.imgExtensions = [
      "jpg",
      "jpeg",
      "bmp",
      "ico",
      "png",
      "gif",
      "webp",
      "tiff",
      "svg"
    ];
    this.insertRegExp = new RegExp(/(\!)?\[\[.+\]\]/g);
    this.linksRegExp = new RegExp(/\[.+\]\(.+\)/g);
    this.filesNeedUpload = {};
  }
  async publish(file, callback) {
    this.files = this.app.vault.getFiles();
    await this.findFilesForUpload(file);
    const total = Object.keys(this.filesNeedUpload).length;
    delete this.filesNeedUpload[file.path];
    let i = 0;
    for (let key in this.filesNeedUpload) {
      callback({
        progress: Math.round(i / total * 100),
        filename: this.filesNeedUpload[key].path
      });
      await this.uploadFile(this.filesNeedUpload[key]);
      i++;
    }
    callback({
      progress: 100,
      filename: file.path
    });
    return await this.uploadFile(file);
  }
  async uploadFile(file) {
    let fileData;
    if (file.extension === "md") {
      let data = await this.app.vault.read(file);
      data = this.replaceLinks(data);
      const enc = new TextEncoder();
      fileData = enc.encode(data);
    } else {
      fileData = await this.app.vault.readBinary(file);
    }
    const formData = new FormData();
    const blob = new Blob([fileData], { type: "text/text" });
    formData.append("title", decodeURI(file.name));
    formData.append("file", blob);
    let fileItem = this.settings.publishedFiles.get(file.path);
    if (!fileItem) {
      fileItem = {
        id: v4_default()
      };
      this.settings.publishedFiles.set(file.path, fileItem);
    }
    const suffix = file.extension === "md" ? "html" : file.extension;
    formData.append("id", `${fileItem.id}.${suffix}`);
    const resp = await fetch(`${this.apiBaseUrl}/publish`, {
      method: "POST",
      body: formData
    });
    return await resp.json();
  }
  async findFilesForUpload(file) {
    if (!this.filesNeedUpload[file.path]) {
      this.filesNeedUpload[file.path] = file;
      if (file.extension === "md") {
        let data = await this.app.vault.read(file);
        const inserts = data.match(this.insertRegExp);
        if (inserts) {
          for (let idx in inserts) {
            const filename = inserts[idx].startsWith("[[") ? inserts[idx].substring(2, inserts[idx].length - 2) : inserts[idx].substring(3, inserts[idx].length - 2);
            const fl = this.findFile(filename);
            if (fl) {
              await this.findFilesForUpload(fl);
            }
          }
        }
        const links = data.match(this.linksRegExp);
        if (links) {
          for (let idx in links) {
            const filename = links[idx].substring(links[idx].indexOf("(") + 1, links[idx].length - 1);
            const fl = this.findFile(filename);
            if (fl) {
              await this.findFilesForUpload(fl);
            }
          }
        }
      }
    }
    return;
  }
  findFile(name) {
    name = decodeURI(name);
    const filtered = this.files.filter((file) => file.path.indexOf(name) > -1);
    if (filtered.length === 1) {
      return filtered[0];
    }
    return null;
  }
  replaceLinks(data) {
    var _a, _b;
    const inserts = data.match(this.insertRegExp);
    if (inserts) {
      for (let idx in inserts) {
        const filename = inserts[idx].startsWith("[[") ? inserts[idx].substring(2, inserts[idx].length - 2) : inserts[idx].substring(3, inserts[idx].length - 2);
        const insertedFile = this.findFile(filename);
        if (insertedFile) {
          const fileItem = this.settings.publishedFiles.get(insertedFile.path);
          if (fileItem) {
            let suffix = insertedFile.extension;
            if (suffix === "md") {
              suffix = "html";
            }
            if (this.imgExtensions.indexOf(insertedFile.extension) > -1) {
              data = data.replace(
                inserts[idx],
                `![${insertedFile.name.substring(0, (_a = insertedFile.name.lastIndexOf(".")) != null ? _a : -1)}](${this.basePath}/${fileItem.id}.${suffix})`
              );
            } else {
              data = data.replace(
                inserts[idx],
                `[${insertedFile.name.substring(0, (_b = insertedFile.name.lastIndexOf(".")) != null ? _b : -1)}](${this.basePath}/${fileItem.id}.${suffix})`
              );
            }
          }
        }
      }
    }
    const links = data.match(this.linksRegExp);
    if (links) {
      for (let idx in links) {
        const filename = links[idx].substring(links[idx].indexOf("(") + 1, links[idx].length - 1);
        const linkedFile = this.findFile(filename);
        if (linkedFile) {
          const fileItem = this.settings.publishedFiles.get(linkedFile.path);
          if (fileItem) {
            let suffix = linkedFile.extension;
            if (suffix === "md") {
              suffix = "html";
            }
            data = data.replace(
              filename,
              `${this.basePath}/${fileItem.id}.${suffix}`
            );
          }
        }
      }
    }
    return data;
  }
};

// src/popups/published.ts
var import_obsidian = require("obsidian");
var PublishSuccessModal = class extends import_obsidian.Modal {
  constructor(app, resp) {
    super(app);
    this.response = resp;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.addClass("pickly-modal");
    contentEl.createEl("h1", { text: "The note was published" });
    contentEl.createEl("input", { value: this.response.url, type: "text" }, (elm) => {
      elm.select();
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Open").onClick(async () => {
      const link = contentEl.createEl("a", { cls: "hidden", href: this.response.url });
      link.click();
    })).addButton((btn) => btn.setButtonText("Copy").setCta().onClick(async () => {
      await navigator.clipboard.writeText(this.response.url);
      new import_obsidian.Notice("Link was copied");
      this.close();
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/popups/piblushing.ts
var import_obsidian2 = require("obsidian");
var PublishingModal = class extends import_obsidian2.Modal {
  constructor(app) {
    super(app);
    this.canClose = false;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.addClass("pickly-modal");
    contentEl.createEl("h1", { text: "Publishing..." });
    this.progress = contentEl.createEl("progress");
    this.progress.max = 100;
    this.description = contentEl.createEl("p", { text: "Preparing files..." });
  }
  setProgress(progress) {
    this.progress.value = progress.progress;
    this.description.innerText = `Uploading "${progress.filename}"`;
  }
  setCanClose(val) {
    this.canClose = val;
  }
  close() {
    if (this.canClose) {
      super.close();
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var PicklyPageBlendPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.publisher = new Publisher(this.app, this.settings);
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.addItem(menu, file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        this.addItem(menu, view.file);
      })
    );
    this.addCommand({
      id: "pickly-page-blend",
      name: "Publish with PageBlend",
      callback: async () => {
        var _a;
        const file = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.file;
        if (file) {
          await this.publish(file);
        } else {
          new import_obsidian3.Notice("There is no file for publish");
        }
      }
    });
    this.registerEvent(this.app.vault.on("delete", (file) => {
      this.settings.publishedFiles.delete(file.path);
      this.saveSettings();
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      const oldItem = this.settings.publishedFiles.get(oldPath);
      if (oldItem) {
        this.settings.publishedFiles.set(file.path, {
          id: oldItem.id
        });
      }
      this.saveSettings();
    }));
  }
  addItem(menu, file) {
    if (file !== null && file instanceof import_obsidian3.TFile) {
      menu.addItem((item) => {
        item.setTitle("Publish with PageBlend").setIcon("publish").onClick(async () => {
          await this.publish(file);
        });
      });
    }
  }
  async publish(file) {
    const modal = new PublishingModal(this.app);
    modal.open();
    try {
      const resp = await this.publisher.publish(
        file,
        (item) => modal.setProgress(item)
      );
      new PublishSuccessModal(this.app, resp).open();
    } catch (e) {
      new import_obsidian3.Notice("Something went wrong...");
      console.error(e);
    } finally {
      modal.setCanClose(true);
      modal.close();
      await this.saveSettings();
    }
  }
  async loadSettings() {
    this.settings = {
      publishedFiles: /* @__PURE__ */ new Map()
    };
    const data = await this.loadData();
    if (data.publishedFiles) {
      Object.keys(data.publishedFiles).forEach((key) => {
        if (data.publishedFiles[key].id) {
          this.settings.publishedFiles.set(key, {
            id: data.publishedFiles[key].id
          });
        }
      });
    }
  }
  async saveSettings() {
    const settings = { publishedFiles: {} };
    this.settings.publishedFiles.forEach((val, key) => {
      settings.publishedFiles[key] = val;
    });
    await this.saveData(settings);
  }
};
